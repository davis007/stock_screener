# やりたいこと

- Y!ファイナンス 買いたい指標の取得 買いたい85％など
- 流動性チェックは 個別と総合に入れたい
```python
df = yf.download("2962.T", interval="5m", period="5d")
zero_rate = (df["Volume"] == 0).mean()
avg_vol = df["Volume"].mean()
```

- 買いたい比率と実際の日足チャートと比べたい


marketwave.pyを制作して以下のクラスを作成
どちらの指数も１０日分の５分足を取得するところから initでデータを取得
def uneri
def wave
として作成しJSONで返却

## うねり指数
1. 銘柄コード　Yf 10日間 5分足を取得する
2. 1日単位で5分足を走査 始まり値が基準値
3. 始値を基準に何度 始値を往復したか？でカウントを取る
   - 例 始値 500 → 510 → 515 → 510 → 495 → 480 → 475 → 460 → 490 → 505（これで2回）
   - 上記は510→495に戻った際に1回をカウント さらに490→505になった際に1回をカウント
   - 始値から上がn% 下がn%で第２第３の数値を取る
   - 例 1日分のデータ例 [3,6%,13.8%]
4. これを10日間走査して1日のAVGを出力する
5. 過去10日間のデータのAVGを出力する

## 流動性指数
	1.	銘柄コードを指定して、YFinanceで5分足を10日分取得する
	2.	1日ごとに5分足を走査して、出来高の平均を出す
      - 出来高が多いほど「動きやすい」＝スコア高
	3.	5分足の中で出来高0の本数を数える
      - 出来高0が多いほど「過疎」＝スコア低
	4.	1日の流動性スコアを次の式で取る
      - 流動性 = (平均出来高 ÷ 最大出来高) × (1 − 出来高ゼロ率)
	5.	10日分の平均を出して「流動性指数」を算出
      → 値が1に近いほど流動性が高い

完了したら
4755　楽天グループでテストしてエラーが出ないかチェック
marketwave.pyファイルはtouchで新規作成してください
------------------------------------------------------------------------
## ストン法
新・統計ロジック（連続足基準）
「朝イチの連続」を探す
9:00からスキャンを開始します。
例：9:00（陽線）→ 9:05（陽線）→ 9:10（陽線）→ 9:15（陰線）
「連続」の終点を特定する
この場合、「アゲの連続」は9:10（3本目）で終わりました。
この「9:10の終値」が、逆張りを検討する天井（＝「ストン」の起点）となります。
統計を取る
統計A（連続の長さ）: この銘柄は、朝イチに平均何本連続でアゲ（サゲ）るクセがあるか？
（例: A銘柄は平均1.2本、B銘柄は平均2.8本... など）
統計B（「往って来い」の確率）:
「アゲの連続」が終わった後（9:15以降）、その「アゲ」の始点（＝9:00の始値）を割り込む（＝「往って来い」達成）確率は何%か？
ストンまでの本数の平均も欲しい

それ、非常に重要な指標ですね！
その平均値がわかれば、その銘柄の「クセ」がより鮮明になります。

* 平均が「1.2本」の銘柄 → ほぼ「1本目ストン」で逆張りが機能するタイプ。
* 平均が「2.8本」の銘柄 → 1本目で逆張りすると危険。「3本目」まで待つべきタイプ。

この「ストンまでの平均本数」を算出するための統計ロジックは、以下のようになります。

------------------------------------------------------------------------

## 「ストンまでの平均本数」算出ロジック

**集計対象:** 過去 $X$ 日間（例: 1年＝約240日）のデータ

### 1. データの分類と集計

過去 $X$ 日間、1日ずつ9:00からスキャンします。

* **パターンA: 「アゲ」スタートの日**
    * 9:00（1本目）が陽線だった日を対象にします。
    * 9:05（2本目）、9:10（3本目）...と見ていき、最初に「陰線」または「十字線（小動き）」が出るまで「陽線が続いた本数」を記録します。
        * 例1: 陽線 → **陰線**... → 記録「1本」
        * 例2: 陽線 → 陽線 → 陽線 → **陰線**... → 記録「3本」
    * 記録した全日数の「平均値」を算出します。
    * → これが**『アゲの後のストンまでの平均本数』**です。

* **パターンB: 「サゲ」スタートの日**
    * 9:00（1本目）が陰線だった日を対象にします。
    * 同様に、最初に「陽線」または「十字線」が出るまで「陰線が続いた本数」を記録します。
        * 例1: 陰線 → **陽線**... → 記録「1本」
        * 例2: 陰線 → 陰線 → **陽線**... → 記録「2本」
    * 記録した全日数の「平均値」を算出します。
    * → これが**『サゲの後のストンまでの平均本数』**です。

### 2. （オプション）総合平均

* 上記AとBで記録した全てのデータ（アゲの連続本数、サゲの連続本数）を全部まとめて平均します。
* → これが**『（方向問わず）ストンまでの平均本数』**です。
------------------------------------------------------------------------

## 弱張り指数
概要: ストン法の亜種（朝イチ5分足の統計戦略）

1. ５分足9:00からスキャンを開始します。

2. （データ収集フェーズ）
   分析対象の全日程（例: 過去1年分）について、以下の基礎データをまず一括で収集・記録します。
    a. 9:00の足（1本目）の陽線/陰線の別。（→これを「スタートタイプ」のフラグとして記録）
    b. 9:05以降の全5分足データ。（陽線/陰線、OHLC）
    c. その日の通し（9:00-15:00）の最高値と最安値。

3. （集計・分析フェーズ）
   上記ステップ2で収集した全データを基に、以下の3つのレポートを同時に算出します。

   [レポート1： 陰線スタート日（押し目買い戦略）の分析]
   * （詳細な分析結果... 例: N本ごとの詳細な勝率、損益分岐点など）

   [レポート2： 陽線スタート日（順張り戦略）の分析]
   * （詳細な分析結果... 例: フィルター別の勝率、平均保有時間など）

   [レポート3： 総合サマリー（銘柄評価）]
   * **スタート確率**: 陽線S [n]%, 陰線S [n]%
   * **1日ボラ幅 (AVG)**: 陽線S [n]%, 陰線S [n]%
   * **平均連続本数**: 陽線S [n]本, 陰線S [n]本
   * **戦略 勝率 (主要ルール)**: 陽線S [n]%, 陰線S [n]%
   * **戦略 期待値 (主要ルール)**: 陽線S [n]円/ティック, 陰線S [n]円/ティック

4. バックテストレポート
    陰線S 戦略
    直近 1ヶ月 勝率: [n]%
    直近 3ヶ月 勝率: [n]%
    直近 6ヶ月 勝率: [n]%
    直近 12ヶ月 勝率: [n]%

    陽線S 戦略
    直近 1ヶ月 勝率: [n]%
    直近 3ヶ月 勝率: [n]%
    直近 6ヶ月 勝率: [n]%
    直近 12ヶ月 勝率: [n]%

---

import pandas as pd
from datetime import datetime
# import yfinance as yf # (yfinanceは実行済みと仮定)

# --- 前提 ---
# raw_data = yf.download(tickers="XXXX.T", period="1y", interval="5m")
# (raw_data には yfinance で取得した5分足OHLCデータが格納されている)


# ==============================================================================
# STEP 1: バックテスト（戦略シミュレーション）関数の定義
# ==============================================================================

def simulate_insen_strategy(daily_data):
    """
    [陰線S] 戦略のシミュレーション
    ルール: 陰線が続いた後、最初の陽線が出た始値で買い。
           その後、陽線が途切れた（陰線が出た）始値で決済。
    """
    entry_price = 0
    exit_price = 0
    trade_active = False
    first_yosen_found = False

    # 1本目から順にスキャン
    for i in range(len(daily_data)):
        candle = daily_data.iloc[i]
        is_yosen = candle['Close'] > candle['Open']

        # --- エントリーロジック ---
        if not first_yosen_found:
            if is_yosen: # 最初の陽線を発見
                first_yosen_found = True
                # 次の足がない場合はエントリー不可
                if i + 1 < len(daily_data):
                    entry_price = daily_data.iloc[i + 1]['Open'] # 次の足の始値でエントリー
                    trade_active = True
                else:
                    break # エントリーできず終了

        # --- イグジットロジック ---
        elif trade_active:
            if not is_yosen: # 陽線が途切れた（陰線が出現）
                exit_price = candle['Open'] # この陰線の始値で決済
                trade_active = False
                break # トレード終了

    # --- 損益計算 ---
    if entry_price > 0 and exit_price > 0:
        pnl = exit_price - entry_price
        win = 1 if pnl > 0 else 0
        return pnl, win
    elif trade_active: # 引けまで持ち越した場合
        exit_price = daily_data.iloc[-1]['Close'] # 大引けの終値で決済
        pnl = exit_price - entry_price
        win = 1 if pnl > 0 else 0
        return pnl, win

    return 0, 0 # トレード不成立

def simulate_yosen_strategy(daily_data):
    """
    [陽線S] 戦略のシミュレーション
    ルール: 2本目(9:05)の始値で買い。
           その後、陽線が途切れた（陰線が出た）始値で決済。
    """
    if len(daily_data) < 2:
        return 0, 0 # 2本目の足がなければトレード不可

    entry_price = daily_data.iloc[1]['Open'] # 2本目(9:05)の始値でエントリー
    exit_price = 0

    # 2本目からスキャンを開始（1本目はエントリーに使ったため）
    for i in range(1, len(daily_data)):
        candle = daily_data.iloc[i]
        is_yosen = candle['Close'] > candle['Open']

        if not is_yosen: # 陽線が途切れた（陰線が出現）
            exit_price = candle['Open'] # この陰線の始値で決済
            break

    # --- 損益計算 ---
    if exit_price > 0:
        pnl = exit_price - entry_price
        win = 1 if pnl > 0 else 0
        return pnl, win
    else: # 引けまで陽線が続いた場合
        exit_price = daily_data.iloc[-1]['Close'] # 大引けの終値で決済
        pnl = exit_price - entry_price
        win = 1 if pnl > 0 else 0
        return pnl, win

# ==============================================================================
# STEP 2: 日次（にちじ）分析ループ
# ==============================================================================

# 0. 事前準備 (日付データを使いやすくする)
raw_data.reset_index(inplace=True)
# 'Datetime'列が 'index' から列に移動
raw_data['Date'] = pd.to_datetime(raw_data['Datetime']).dt.date # pd.to_datetimeで日付型に

daily_results = [] # このリストに日ごとの分析結果をためていく

# 日付 ('Date') ごとにグループ化してループ
for date, daily_data in raw_data.groupby('Date'):

    if len(daily_data) < 2:
        continue # データが不十分な日はスキップ

    # --- 2a. 基礎データの集計 ---
    first_candle = daily_data.iloc[0]
    start_type = '陽線S' if first_candle['Close'] > first_candle['Open'] else '陰線S'

    day_high = daily_data['High'].max()
    day_low = daily_data['Low'].min()
    volatility_pct = ((day_high - day_low) / day_low) * 100 if day_low > 0 else 0

    initial_streak = 0
    for i in range(len(daily_data)):
        candle = daily_data.iloc[i]
        is_yosen = candle['Close'] > candle['Open']
        if (start_type == '陽線S' and is_yosen) or (start_type == '陰線S' and not is_yosen):
            initial_streak += 1
        else:
            break

    # --- 2b. バックテスト（戦略シミュレーション）の実行 ---
    if start_type == '陽線S':
        pnl, win = simulate_yosen_strategy(daily_data)
    else: # 陰線S
        pnl, win = simulate_insen_strategy(daily_data)

    # --- 2c. 日ごとの結果をリストに保存 ---
    daily_results.append({
        'Date': date, # 'date' オブジェクト
        'start_type': start_type,
        'volatility_pct': volatility_pct,
        'initial_streak': initial_streak,
        'pnl': pnl,
        'win': win
    })

# ==============================================================================
# STEP 3: 最終集計 ＆ レポート出力
# ==============================================================================

def calculate_summary_metrics(df):
    """
    日次結果のDataFrameを受け取り、集計サマリーDataFrameを返すヘルパー関数
    """
    if df.empty:
        # 空の場合は、集計用の空DataFrameを返す
        return pd.DataFrame(columns=[
            'total_days', 'avg_volatility', 'avg_streak', 'total_trades',
            'total_wins', 'total_pnl_wins', 'total_pnl_losses', 'total_losses',
            'start_probability', 'win_rate', 'average_win', 'average_loss', 'expected_value'
        ])

    # --- 3a. バックテストレポート用の集計 ---
    df['pnl_win'] = df.apply(lambda row: row['pnl'] if row['win'] == 1 else 0, axis=1)
    df['pnl_loss'] = df.apply(lambda row: row['pnl'] if row['win'] == 0 and row['pnl'] != 0 else 0, axis=1)

    summary_df = df.groupby('start_type').agg(
        total_days=('Date', 'count'),
        avg_volatility=('volatility_pct', 'mean'),
        avg_streak=('initial_streak', 'mean'),
        total_trades=('pnl', lambda x: (x != 0).sum()),
        total_wins=('win', 'sum'),
        total_pnl_wins=('pnl_win', 'sum'),
        total_pnl_losses=('pnl_loss', 'sum')
    )
    summary_df['total_losses'] = summary_df['total_trades'] - summary_df['total_wins']

    # --- 3b. 最終的な指標の計算 ---
    total_all_days = summary_df['total_days'].sum()
    summary_df['start_probability'] = (summary_df['total_days'] / total_all_days) * 100
    summary_df['win_rate'] = (summary_df['total_wins'] / summary_df['total_trades'].replace(0, 1)) * 100
    summary_df['average_win'] = summary_df['total_pnl_wins'] / summary_df['total_wins'].replace(0, 1)
    summary_df['average_loss'] = summary_df['total_pnl_losses'] / summary_df['total_losses'].replace(0, 1)
    summary_df['expected_value'] = (summary_df['total_pnl_wins'] + summary_df['total_pnl_losses']) / summary_df['total_trades'].replace(0, 1)

    return summary_df

# --- メインの集計処理 ---
if daily_results:
    # リストをDataFrameに変換
    results_df = pd.DataFrame(daily_results)
    # Date列をdatetime型に変換（期間比較のため）
    results_df['Date'] = pd.to_datetime(results_df['Date'])

    # --- 3c. 全期間（12ヶ月）のレポート出力 ---

    # まず、全期間（例: 1年）のサマリーを計算
    summary_all_periods = calculate_summary_metrics(results_df)

    print("\n--- [レポート1 & 2： スタートタイプ別 詳細分析 (全期間)] ---")
    print(summary_all_periods.to_markdown(floatfmt=".2f"))

    print("\n--- [レポート3： 総合サマリー（銘柄評価） (全期間)] ---")
    yosen_data = summary_all_periods.loc.get('陽線S', pd.Series(dtype=float))
    insen_data = summary_all_periods.loc.get('陰線S', pd.Series(dtype=float))

    print(f"・スタート確率: 陽線S {yosen_data.get('start_probability', 0):.1f}%, 陰線S {insen_data.get('start_probability', 0):.1f}%")
    print(f"・1日ボラ幅 (AVG): 陽線S {yosen_data.get('avg_volatility', 0):.2f}%, 陰線S {insen_data.get('avg_volatility', 0):.2f}%")
    print(f"・平均連続本数: 陽線S {yosen_data.get('avg_streak', 0):.1f}本, 陰線S {insen_data.get('avg_streak', 0):.1f}本")
    print(f"・戦略 勝率 (全期間): 陽線S {yosen_data.get('win_rate', 0):.1f}%, 陰線S {insen_data.get('win_rate', 0):.1f}%")

    print("\n--- [バックテストレポート (JSON) (全期間)] ---")
    json_report_df = summary_all_periods[['win_rate', 'average_win', 'average_loss', 'expected_value', 'total_trades']]
    json_output = json_report_df.to_json(orient='index', indent=4, force_ascii=False)
    print(json_output)

    # --- 3d. 【追加】期間別 勝率サマリー (ローリング・ウィンドウ) ---

    print("\n--- [追加レポート： 期間別 勝率サマリー] ---")

    today = pd.Timestamp.today().normalize()
    # 集計したい期間を定義（ラベル、月数）
    periods_def = [('1ヶ月', 1), ('3ヶ月', 3), ('6ヶ月', 6), ('12ヶ月', 12)]

    rolling_yosen_report = "陽線S 戦略\n"
    rolling_insen_report = "陰線S 戦略\n"

    for label, months in periods_def:
        # 期間の開始日を計算
        start_date = today - pd.DateOffset(months=months)

        # 該当期間のデータだけを抽出
        period_df = results_df[results_df['Date'] >= start_date].copy()

        # 該当期間のサマリーを計算
        period_summary = calculate_summary_metrics(period_df)

        # 勝率を取得（データがない場合は 'N/A'）
        y_rate = period_summary.loc.get('陽線S', {}).get('win_rate')
        i_rate = period_summary.loc.get('陰線S', {}).get('win_rate')

        y_rate_str = f"{y_rate:.1f}%" if y_rate is not None else "N/A (データなし)"
        i_rate_str = f"{i_rate:.1f}%" if i_rate is not None else "N/A (データなし)"

        rolling_yosen_report += f"* 直近 {label: <4} 勝率: {y_rate_str}\n"
        rolling_insen_report += f"* 直近 {label: <4} 勝率: {i_rate_str}\n"

    print(rolling_yosen_report)
    print(rolling_insen_report)

else:
    print("分析対象となる十分なデータがありませんでした。")